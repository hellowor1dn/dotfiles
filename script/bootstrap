#!/usr/bin/env bash
#
# update dotfiles from git and install

# -----------------------------------------------------------------------------
# | Errors                                                                     |
# -----------------------------------------------------------------------------

declare -r E_OS_NOT_SUPPORTED=101

# -----------------------------------------------------------------------------
# | Global variables                                                           |
# -----------------------------------------------------------------------------

declare -r INIT_SECTION=0
declare -r REPO_SECTION=1
declare -r DIR_SECTION=2
declare -r BIN_SECTION=3
declare -r SYM_SECTION=4
declare -r TOOL_SECTION=5
declare -r APPS_SECTION=6
declare -r PREF_SECTION=7
declare -r EXTR_SECTION=8

# -----------------------------------------------------------------------------
# | System                                                                     |
# -----------------------------------------------------------------------------

# is_supported_version(actual, expected): test if compatible version
is_supported_version() {
    declare -a v1="${1//./ }"
    declare -a v2="${2//./ }"
    local i=""

    # Fill empty positions in v1 with zeros
    for (( i="${#v1[@]}"; i<"${#v2[@]}"; i++ )); do
        v1[i]=0
    done

    for (( i=0; i<"${#v1[@]}"; i++ )); do
        # Fill empty positions in v2 with zeros
        if [[ -z "${v2[i]}" ]]; then
            v2[i]=0
        fi
        # test if version is valid
        if [[ 10#"${v1[i]}" < 10#"${v2[i]}" ]]; then
            return 1
        fi
    done

    return 0
}

# verify_os(): verify current computer is running a supported os
#   Supported: OSX
verify_os() {
    local -r OS="$(get_os)"
    declare OS_VERSION=""

    # OSX El Capitan
    declare -r MINIMUM_OS_X_VERSION="10.11"
    # TODO: Ubuntu Trusty
    # declare -r MINIMUM_UBUNTU_VERSION="14.04"

    if [[ "${OS}" == "osx" ]]; then
        OS_VERSION="$(sw_vers -productVersion)"
        is_supported_version "${OS_VERSION}" "${MINIMUM_OS_X_VERSION}" \
            && return 0 \
            || print_error "Sorry, this script is intended only for OS X ${MINIMUM_OS_X_VERSION}+\n"
    elif [[ "${OS}" == "ubuntu" ]]; then
        # OS_VERSION="$(lsb_release -d | cut -f2 | cut -d' ' -f2)"
        # is_supported_version "${OS_VERSION}" "${MINIMUM_UBUNTU_VERSION}" \
        #     && return 0 \
        #     || printf "Sorry, this script is intended only for Ubuntu ${MINIMUM_UBUNTU_VERSION}+\n"
        print_error 'Sorry, this script is intended only for OS X!\n'
    else
        print_error 'Sorry, this script is intended only for OS X!\n'
    fi

    return 1
}

# -----------------------------------------------------------------------------
# | Functions                                                                  |
# -----------------------------------------------------------------------------

remove_logs() {
    if [[ -e "${ERROR_FILE}" ]]; then
        rm -rf "${ERROR_FILE}"
        status_no_exit "Removed error log"
    fi
    if [[ -e "${INFO_FILE}" ]]; then
        rm -rf "${INFO_FILE}"
        status_no_exit "removed info log"
    fi
}

# end_prompt(): pause program before termination if no automatic restart
end_prompt() {
    print_in_blue "\n Press any key to continue... "
    read -n 1 &> /dev/null
    printf "\n"
}

# -----------------------------------------------------------------------------
# | Main                                                                       |
# -----------------------------------------------------------------------------

main() {
    # switch path to script source
    cd "$(dirname "${BASH_SOURCE}")" \
        && source "utils.sh"

    # TODO: do something when script is run from ~/bin
    if [[ "$?" -ne 0 ]]; then
        echo "Error: dotfile utils not found"
        exit 1
    fi

    verify_os || errexit "Error: OS is not suported" "${E_OS_NOT_SUPPORTED}"

    clear
    print_section "Beginning bootstrap script"
    local bootstrap_section=0
    if [[ "$#" -ge 1 ]]; then
        bootstrap_section="$1"
    fi

    # if boostrap was run before, remove existing log
    remove_logs

    # Confirm fresh or existing install
    local fresh=1
    confirm "Is this a fresh install?"
    if status_code; then
        fresh=0
        print_fix "Installing all components!"
    else
        fresh=1
        print_fix "Running updates..."
    fi
    # ask for sudo
    request_sudo

    # run init
    if [[ "${bootstrap_section}" -le "${INIT_SECTION}" ]]; then
        ../os/init.sh "${fresh}"
        exit_on_fail "Initialization failed"
        print_separator_large
        ((bootstrap_section+=1))
    fi

    # check and update git repo
    if [[ "${bootstrap_section}" -le "${REPO_SECTION}" ]]; then
        ../os/repository.sh "${fresh}"
        exit_on_fail "Repository check failed"
        print_separator_large
        ((bootstrap_section+=1))
    fi

    # create directories
    if [[ "${bootstrap_section}" -le "${DIR_SECTION}" ]]; then
        ../os/directories.sh "${fresh}"
        exit_on_fail "Directory creation failed"
        print_separator_large
        ((bootstrap_section+=1))
    fi

    # sync scripts
    if [[ "${bootstrap_section}" -le "${BIN_SECTION}" ]]; then
        ../os/bin.sh "${fresh}"
        exit_on_fail "Script synchronization failed"
        print_separator_large
        ((bootstrap_section+=1))
    fi

    # create symbolic links
    if [[ "${bootstrap_section}" -le "${SYM_SECTION}" ]]; then
        ../os/symlinks.sh "${fresh}"
        exit_on_fail "Symbolic link creation failed"
        print_separator_large
        ((bootstrap_section+=1))
    fi

    # ---

    # download/install tools
    if [[ "${bootstrap_section}" -le "${TOOL_SECTION}" ]]; then
        ../os/tools.sh "${fresh}"
        exit_on_fail "Tool installation failed"
        print_separator_large
        ((bootstrap_section+=1))
    fi

    # download/install applications
    if [[ "${bootstrap_section}" -le "${APPS_SECTION}" ]]; then
        ../os/apps.sh "${fresh}"
        exit_on_fail "Application installation failed"
        print_separator_large
        ((bootstrap_section+=1))
    fi

    # set preferences
    if [[ "${bootstrap_section}" -le "${PREF_SECTION}" ]]; then
        ../os/preferences.sh "${fresh}"
        exit_on_fail "Preferences failed"
        print_separator_large
        ((bootstrap_section+=1))
    fi

    # perform additional operations
    if [[ "${bootstrap_section}" -le "${EXTR_SECTION}" ]]; then
        ../os/extras.sh "${fresh}"
        print_separator_large
        ((bootstrap_section+=1))
    fi

    echo "$(cat "${INFO_FILE}")"

    print_section "Bootstrap script complete"
    confirm "Do you want to restart?"
    if status_code; then
        print_fix "Restarting now!"
        ../os/restart.sh
        # no need to kill sudo when restarting
    else
        print_fix "Manual restart required"
        end_prompt
        kill_sudo
    fi
}

main "$1"
